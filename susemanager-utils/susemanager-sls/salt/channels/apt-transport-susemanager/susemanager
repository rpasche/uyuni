#! /usr/bin/python -u
#
# The Susemanager Acquire Method
#
# Author:  Simon Lukasik <xlukas08 [at] stud.fit.vutbr.cz>
# Date:    2011-01-01
# License: GPLv2
#
# Copyright (c) 1999--2012 Red Hat, Inc.
#
# This method is shamelessly copied from the
# apt-transport-spacewalk package and changed to work
# with susemanager or Uyuni
#
# Author:  Robert Paschedag <robert.paschedag@web.de>
# Date:    2018-10-30
# License: GPLv2
#
# This software is licensed to you under the GNU General Public License,
# version 2 (GPLv2). There is NO WARRANTY for this software, express or
# implied, including the implied warranties of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
# along with this software; if not, see
# http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.


import sys
import re
import hashlib
import httplib
import warnings
warnings.filterwarnings("ignore", message="the md5 module is deprecated; use hashlib instead")

from urlparse import urlparse

CHANNEL_TOKENS_CONFIG = '/etc/susemanager_tokens.conf'

class pkg_acquire_method:
    """
    This is slightly modified python variant of apt-pkg/acquire-method.
    It is a skeleton class that implements only very basic of apt methods
    functionality.
    """
    __eof = False

    def __init__(self):
        print "100 Capabilities\nVersion: 1.0\nSingle-Instance: true\n\n",

    def __get_next_msg(self):
        """
        Apt uses for communication with its methods the text protocol similar
        to http. This function parses the protocol messages from stdin.
        """
        if self.__eof:
            return None
        result = {};
        line = sys.stdin.readline()
        while line == '\n':
            line = sys.stdin.readline()
        if not line:
            self.__eof = True
            return None
        s = line.split(" ", 1)
        result['_number'] = int(s[0])
        result['_text'] = s[1].strip()

        while not self.__eof:
            line = sys.stdin.readline()
            if not line:
                self.__eof = True
                return result
            if line == '\n':
                return result
            s = line.split(":", 1)
            result[s[0]] = s[1].strip()

    def __dict2msg(self, msg):
        """Convert dictionary to http like message"""
        result = ""
        for item in msg.keys():
            if msg[item] != None:
                result += item + ": " + msg[item] + "\n"
        return result

    def status(self, **kwargs):
        print "102 Status\n%s\n" % self.__dict2msg(kwargs),

    def uri_start(self, msg):
        print "200 URI Start\n%s\n" % self.__dict2msg(msg),

    def uri_done(self, msg):
        print "201 URI Done\n%s\n" % self.__dict2msg(msg),

    def uri_failure(self, msg):
        print "400 URI Failure\n%s\n" % self.__dict2msg(msg),

    def run(self):
        """Loop through requests on stdin"""
        while True:
            msg = self.__get_next_msg()
            if msg == None:
                return 0
            if msg['_number'] == 600:
                try:
                    self.fetch(msg)
                except Exception, e:
                    self.fail(e.__class__.__name__ + ": " + str(e))
            else:
                return 100


class susemanager_method(pkg_acquire_method):
    """
    Susemanager acquire method
    """
    http_headers = None
    tokens = None
    conn = None
    not_registered_msg = 'This system is not registered with the susemanager server'

    def fail(self, message = not_registered_msg):
        self.uri_failure({'URI': self.uri,
                          'Message': message})

    def load_tokens(self):
        if self.tokens == None:
            self.tokens = {}
            f = open(CHANNEL_TOKENS_CONFIG, 'r')
            for line in f.readlines():
                if not ": " in line:
                    continue
                line = line.strip()
                chan, token = line.split(': ')
                self.tokens[chan] = token
            f.close()
    
    def __init_headers(self):
        if self.http_headers == None:
            self.http_headers = {}
            self.http_headers['X-RHN-Transport-Capability'] = 'follow-redirects=3'

    def __make_conn(self):
        if self.conn == None:
            self.conn = httplib.HTTPSConnection(self.uri_parsed.netloc)

    def __transform_document(self, document):
        """Transform url given by apt to real susemanager url"""
        document = document.replace(self.remote_filename, self.request_filename)
        document = document.replace('/XMLRPC/GET-REQ/', '/rhn/manager/download/', 1)
        document = document.replace('dists/', '/rhn/manager/download/', 1)
        document = re.sub('/binary-[\d\w]*/', '/', document, 1)
        document = re.sub('/(InRelease|Release|Release.gpg)', r'/repodata/\1', document, 1)
        # point i18n to wrong path so we dont get traceback mails when not having i18n in repodata
        document = document.replace('repodata/i18n', '/i18n', 1)
        # append the token for the channel
        for chan, token in self.tokens.items():
            if chan in document:
                document = "%s?%s" % (document, token)
                break
        return document

    def fetch(self, msg):
        """
        Fetch the content from susemanager server to the file.

        Acording to the apt protocol msg must contain: 'URI' and 'Filename'.
        Other possible keys are: 'Last-Modified', 'Index-File', 'Fail-Ignore'
        """
        self.uri = msg['URI']
        self.uri_parsed = urlparse(msg['URI'])
        self.filename = msg['Filename']
        # currently, the filename stored on susemanager server
        # is wrong for Debian packages as name and version
        # is seperated with a '_' and NOT with a '-'
        # so transform
        self.remote_filename = re.sub(r'^.*/getPackage/(.*)$', r'\1', self.uri, 1)
        self.request_filename = self.remote_filename.replace('_', '-')

        document = self.__transform_document(self.uri_parsed.path)

        self.__init_headers()
        self.__make_conn()

        self.conn.request("GET", "/" + document, headers = self.http_headers)
        self.status(URI = self.uri, Message = 'Waiting for headers')

        res = self.conn.getresponse()
        if res.status != 200:
            self.uri_failure({'URI': self.uri,
                              'Message': str(res.status) + '  ' + res.reason,
                              'FailReason': 'HttpError' + str(res.status)})
            while True:
                data = res.read(4096)
                if not len(data): break
            res.close()
            return

        self.uri_start({'URI': self.uri,
                        'Size': res.getheader('content-length'),
                        'Last-Modified': res.getheader('last-modified')})

        f = open(self.filename, "w")
        hash_sha256 = hashlib.sha256()
        hash_md5 = hashlib.md5()
        while True:
            data = res.read(4096)
            if not len(data):
                break
            hash_sha256.update(data)
            hash_md5.update(data)
            f.write(data)
        res.close()
        f.close()

        self.uri_done({'URI': self.uri,
                       'Filename': self.filename,
                       'Size': res.getheader('content-length'),
                       'Last-Modified': res.getheader('last-modified'),
                       'MD5-Hash': hash_md5.hexdigest(),
                       'MD5Sum-Hash': hash_md5.hexdigest(),
                       'SHA256-Hash': hash_sha256.hexdigest()})

    def __del__(self):
        if self.conn:
            self.conn.close()


if __name__ == '__main__':
    try:
        method = susemanager_method()
        method.load_tokens()
        ret = method.run()
        sys.exit(ret)
    except KeyboardInterrupt:
        pass
